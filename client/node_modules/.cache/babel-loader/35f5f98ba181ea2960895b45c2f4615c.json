{"ast":null,"code":"/*!\n * \n *               jsPDF AutoTable plugin v3.5.29\n *\n *               Copyright (c) 2023 Simon Bengtsson, https://github.com/simonbengtsson/jsPDF-AutoTable\n *               Licensed under the MIT License.\n *               http://opensource.org/licenses/mit-license\n *\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory(function webpackLoadOptionalExternalModule() {\n    try {\n      return require(\"jspdf\");\n    } catch (e) {}\n  }());else if (typeof define === 'function' && define.amd) define([\"jspdf\"], factory);else {\n    var a = typeof exports === 'object' ? factory(function webpackLoadOptionalExternalModule() {\n      try {\n        return require(\"jspdf\");\n      } catch (e) {}\n    }()) : factory(root[\"jspdf\"]);\n    for (var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n  }\n})(typeof globalThis !== 'undefined' ? globalThis : typeof this !== 'undefined' ? this : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : global, function (__WEBPACK_EXTERNAL_MODULE__84__) {\n  return (/******/function () {\n      // webpackBootstrap\n      /******/\n      \"use strict\";\n\n      /******/\n      var __webpack_modules__ = {\n        /***/662: /***/function (__unused_webpack_module, exports) {\n          var __extends = this && this.__extends || function () {\n            var extendStatics = function (d, b) {\n              extendStatics = Object.setPrototypeOf || {\n                __proto__: []\n              } instanceof Array && function (d, b) {\n                d.__proto__ = b;\n              } || function (d, b) {\n                for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n              };\n              return extendStatics(d, b);\n            };\n            return function (d, b) {\n              if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n              extendStatics(d, b);\n              function __() {\n                this.constructor = d;\n              }\n              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n          }();\n          Object.defineProperty(exports, \"__esModule\", {\n            value: true\n          });\n          exports.CellHookData = exports.HookData = void 0;\n          var HookData = /** @class */function () {\n            function HookData(doc, table, cursor) {\n              this.table = table;\n              this.pageNumber = table.pageNumber;\n              this.pageCount = this.pageNumber;\n              this.settings = table.settings;\n              this.cursor = cursor;\n              this.doc = doc.getDocument();\n            }\n            return HookData;\n          }();\n          exports.HookData = HookData;\n          var CellHookData = /** @class */function (_super) {\n            __extends(CellHookData, _super);\n            function CellHookData(doc, table, cell, row, column, cursor) {\n              var _this = _super.call(this, doc, table, cursor) || this;\n              _this.cell = cell;\n              _this.row = row;\n              _this.column = column;\n              _this.section = row.section;\n              return _this;\n            }\n            return CellHookData;\n          }(HookData);\n          exports.CellHookData = CellHookData;\n\n          /***/\n        },\n\n        /***/790: /***/function (__unused_webpack_module, exports, __webpack_require__) {\n          Object.defineProperty(exports, \"__esModule\", {\n            value: true\n          });\n          var htmlParser_1 = __webpack_require__(148);\n          var autoTableText_1 = __webpack_require__(938);\n          var documentHandler_1 = __webpack_require__(323);\n          var inputParser_1 = __webpack_require__(587);\n          var tableDrawer_1 = __webpack_require__(49);\n          var tableCalculator_1 = __webpack_require__(858);\n          function default_1(jsPDF) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            jsPDF.API.autoTable = function () {\n              var args = [];\n              for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n              }\n              var options;\n              if (args.length === 1) {\n                options = args[0];\n              } else {\n                console.error('Use of deprecated autoTable initiation');\n                options = args[2] || {};\n                options.columns = args[0];\n                options.body = args[1];\n              }\n              var input = (0, inputParser_1.parseInput)(this, options);\n              var table = (0, tableCalculator_1.createTable)(this, input);\n              (0, tableDrawer_1.drawTable)(this, table);\n              return this;\n            };\n            // Assign false to enable `doc.lastAutoTable.finalY || 40` sugar\n            jsPDF.API.lastAutoTable = false;\n            jsPDF.API.previousAutoTable = false; // deprecated in v3\n            jsPDF.API.autoTable.previous = false; // deprecated in v3\n            jsPDF.API.autoTableText = function (text, x, y, styles) {\n              (0, autoTableText_1.default)(text, x, y, styles, this);\n            };\n            jsPDF.API.autoTableSetDefaults = function (defaults) {\n              documentHandler_1.DocHandler.setDefaults(defaults, this);\n              return this;\n            };\n            jsPDF.autoTableSetDefaults = function (defaults, doc) {\n              documentHandler_1.DocHandler.setDefaults(defaults, doc);\n            };\n            jsPDF.API.autoTableHtmlToJson = function (tableElem, includeHiddenElements) {\n              if (includeHiddenElements === void 0) {\n                includeHiddenElements = false;\n              }\n              if (typeof window === 'undefined') {\n                console.error('Cannot run autoTableHtmlToJson in non browser environment');\n                return null;\n              }\n              var doc = new documentHandler_1.DocHandler(this);\n              var _a = (0, htmlParser_1.parseHtml)(doc, tableElem, window, includeHiddenElements, false),\n                head = _a.head,\n                body = _a.body;\n              var columns = head[0].map(function (c) {\n                return c.content;\n              });\n              return {\n                columns: columns,\n                rows: body,\n                data: body\n              };\n            };\n            /**\n             * @deprecated\n             */\n            jsPDF.API.autoTableEndPosY = function () {\n              console.error('Use of deprecated function: autoTableEndPosY. Use doc.lastAutoTable.finalY instead.');\n              var prev = this.lastAutoTable;\n              if (prev && prev.finalY) {\n                return prev.finalY;\n              } else {\n                return 0;\n              }\n            };\n            /**\n             * @deprecated\n             */\n            jsPDF.API.autoTableAddPageContent = function (hook) {\n              console.error('Use of deprecated function: autoTableAddPageContent. Use jsPDF.autoTableSetDefaults({didDrawPage: () => {}}) instead.');\n              if (!jsPDF.API.autoTable.globalDefaults) {\n                jsPDF.API.autoTable.globalDefaults = {};\n              }\n              jsPDF.API.autoTable.globalDefaults.addPageContent = hook;\n              return this;\n            };\n            /**\n             * @deprecated\n             */\n            jsPDF.API.autoTableAddPage = function () {\n              console.error('Use of deprecated function: autoTableAddPage. Use doc.addPage()');\n              this.addPage();\n              return this;\n            };\n          }\n          exports[\"default\"] = default_1;\n\n          /***/\n        },\n\n        /***/938: /***/function (__unused_webpack_module, exports) {\n          Object.defineProperty(exports, \"__esModule\", {\n            value: true\n          });\n          /**\n           * Improved text function with halign and valign support\n           * Inspiration from: http://stackoverflow.com/questions/28327510/align-text-right-using-jspdf/28433113#28433113\n           */\n          function default_1(text, x, y, styles, doc) {\n            styles = styles || {};\n            var FONT_ROW_RATIO = 1.15;\n            var k = doc.internal.scaleFactor;\n            var fontSize = doc.internal.getFontSize() / k;\n            var splitRegex = /\\r\\n|\\r|\\n/g;\n            var splitText = '';\n            var lineCount = 1;\n            if (styles.valign === 'middle' || styles.valign === 'bottom' || styles.halign === 'center' || styles.halign === 'right') {\n              splitText = typeof text === 'string' ? text.split(splitRegex) : text;\n              lineCount = splitText.length || 1;\n            }\n            // Align the top\n            y += fontSize * (2 - FONT_ROW_RATIO);\n            if (styles.valign === 'middle') y -= lineCount / 2 * fontSize * FONT_ROW_RATIO;else if (styles.valign === 'bottom') y -= lineCount * fontSize * FONT_ROW_RATIO;\n            if (styles.halign === 'center' || styles.halign === 'right') {\n              var alignSize = fontSize;\n              if (styles.halign === 'center') alignSize *= 0.5;\n              if (splitText && lineCount >= 1) {\n                for (var iLine = 0; iLine < splitText.length; iLine++) {\n                  doc.text(splitText[iLine], x - doc.getStringUnitWidth(splitText[iLine]) * alignSize, y);\n                  y += fontSize * FONT_ROW_RATIO;\n                }\n                return doc;\n              }\n              x -= doc.getStringUnitWidth(text) * alignSize;\n            }\n            if (styles.halign === 'justify') {\n              doc.text(text, x, y, {\n                maxWidth: styles.maxWidth || 100,\n                align: 'justify'\n              });\n            } else {\n              doc.text(text, x, y);\n            }\n            return doc;\n          }\n          exports[\"default\"] = default_1;\n\n          /***/\n        },\n\n        /***/200: /***/function (__unused_webpack_module, exports) {\n          Object.defineProperty(exports, \"__esModule\", {\n            value: true\n          });\n          exports.parseSpacing = exports.getFillStyle = exports.addTableBorder = exports.getStringWidth = void 0;\n          function getStringWidth(text, styles, doc) {\n            doc.applyStyles(styles, true);\n            var textArr = Array.isArray(text) ? text : [text];\n            var widestLineWidth = textArr.map(function (text) {\n              return doc.getTextWidth(text);\n            }).reduce(function (a, b) {\n              return Math.max(a, b);\n            }, 0);\n            return widestLineWidth;\n          }\n          exports.getStringWidth = getStringWidth;\n          function addTableBorder(doc, table, startPos, cursor) {\n            var lineWidth = table.settings.tableLineWidth;\n            var lineColor = table.settings.tableLineColor;\n            doc.applyStyles({\n              lineWidth: lineWidth,\n              lineColor: lineColor\n            });\n            var fillStyle = getFillStyle(lineWidth, false);\n            if (fillStyle) {\n              doc.rect(startPos.x, startPos.y, table.getWidth(doc.pageSize().width), cursor.y - startPos.y, fillStyle);\n            }\n          }\n          exports.addTableBorder = addTableBorder;\n          function getFillStyle(lineWidth, fillColor) {\n            var drawLine = lineWidth > 0;\n            var drawBackground = fillColor || fillColor === 0;\n            if (drawLine && drawBackground) {\n              return 'DF'; // Fill then stroke\n            } else if (drawLine) {\n              return 'S'; // Only stroke (transparent background)\n            } else if (drawBackground) {\n              return 'F'; // Only fill, no stroke\n            } else {\n              return null;\n            }\n          }\n          exports.getFillStyle = getFillStyle;\n          function parseSpacing(value, defaultValue) {\n            var _a, _b, _c, _d;\n            value = value || defaultValue;\n            if (Array.isArray(value)) {\n              if (value.length >= 4) {\n                return {\n                  top: value[0],\n                  right: value[1],\n                  bottom: value[2],\n                  left: value[3]\n                };\n              } else if (value.length === 3) {\n                return {\n                  top: value[0],\n                  right: value[1],\n                  bottom: value[2],\n                  left: value[1]\n                };\n              } else if (value.length === 2) {\n                return {\n                  top: value[0],\n                  right: value[1],\n                  bottom: value[0],\n                  left: value[1]\n                };\n              } else if (value.length === 1) {\n                value = value[0];\n              } else {\n                value = defaultValue;\n              }\n            }\n            if (typeof value === 'object') {\n              if (typeof value.vertical === 'number') {\n                value.top = value.vertical;\n                value.bottom = value.vertical;\n              }\n              if (typeof value.horizontal === 'number') {\n                value.right = value.horizontal;\n                value.left = value.horizontal;\n              }\n              return {\n                left: (_a = value.left) !== null && _a !== void 0 ? _a : defaultValue,\n                top: (_b = value.top) !== null && _b !== void 0 ? _b : defaultValue,\n                right: (_c = value.right) !== null && _c !== void 0 ? _c : defaultValue,\n                bottom: (_d = value.bottom) !== null && _d !== void 0 ? _d : defaultValue\n              };\n            }\n            if (typeof value !== 'number') {\n              value = defaultValue;\n            }\n            return {\n              top: value,\n              right: value,\n              bottom: value,\n              left: value\n            };\n          }\n          exports.parseSpacing = parseSpacing;\n\n          /***/\n        },\n\n        /***/913: /***/function (__unused_webpack_module, exports) {\n          var __extends = this && this.__extends || function () {\n            var extendStatics = function (d, b) {\n              extendStatics = Object.setPrototypeOf || {\n                __proto__: []\n              } instanceof Array && function (d, b) {\n                d.__proto__ = b;\n              } || function (d, b) {\n                for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n              };\n              return extendStatics(d, b);\n            };\n            return function (d, b) {\n              if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n              extendStatics(d, b);\n              function __() {\n                this.constructor = d;\n              }\n              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n          }();\n          Object.defineProperty(exports, \"__esModule\", {\n            value: true\n          });\n          exports.getTheme = exports.defaultStyles = exports.HtmlRowInput = exports.FONT_ROW_RATIO = void 0;\n          /**\n           * Ratio between font size and font height. The number comes from jspdf's source code\n           */\n          exports.FONT_ROW_RATIO = 1.15;\n          var HtmlRowInput = /** @class */function (_super) {\n            __extends(HtmlRowInput, _super);\n            function HtmlRowInput(element) {\n              var _this = _super.call(this) || this;\n              _this._element = element;\n              return _this;\n            }\n            return HtmlRowInput;\n          }(Array);\n          exports.HtmlRowInput = HtmlRowInput;\n          // Base style for all themes\n          function defaultStyles(scaleFactor) {\n            return {\n              font: 'helvetica',\n              fontStyle: 'normal',\n              overflow: 'linebreak',\n              fillColor: false,\n              textColor: 20,\n              halign: 'left',\n              valign: 'top',\n              fontSize: 10,\n              cellPadding: 5 / scaleFactor,\n              lineColor: 200,\n              lineWidth: 0,\n              cellWidth: 'auto',\n              minCellHeight: 0,\n              minCellWidth: 0\n            };\n          }\n          exports.defaultStyles = defaultStyles;\n          function getTheme(name) {\n            var themes = {\n              striped: {\n                table: {\n                  fillColor: 255,\n                  textColor: 80,\n                  fontStyle: 'normal'\n                },\n                head: {\n                  textColor: 255,\n                  fillColor: [41, 128, 185],\n                  fontStyle: 'bold'\n                },\n                body: {},\n                foot: {\n                  textColor: 255,\n                  fillColor: [41, 128, 185],\n                  fontStyle: 'bold'\n                },\n                alternateRow: {\n                  fillColor: 245\n                }\n              },\n              grid: {\n                table: {\n                  fillColor: 255,\n                  textColor: 80,\n                  fontStyle: 'normal',\n                  lineWidth: 0.1\n                },\n                head: {\n                  textColor: 255,\n                  fillColor: [26, 188, 156],\n                  fontStyle: 'bold',\n                  lineWidth: 0\n                },\n                body: {},\n                foot: {\n                  textColor: 255,\n                  fillColor: [26, 188, 156],\n                  fontStyle: 'bold',\n                  lineWidth: 0\n                },\n                alternateRow: {}\n              },\n              plain: {\n                head: {\n                  fontStyle: 'bold'\n                },\n                foot: {\n                  fontStyle: 'bold'\n                }\n              }\n            };\n            return themes[name];\n          }\n          exports.getTheme = getTheme;\n\n          /***/\n        },\n\n        /***/259: /***/function (__unused_webpack_module, exports, __webpack_require__) {\n          Object.defineProperty(exports, \"__esModule\", {\n            value: true\n          });\n          exports.parseCss = void 0;\n          // Limitations\n          // - No support for border spacing\n          // - No support for transparency\n          var common_1 = __webpack_require__(200);\n          function parseCss(supportedFonts, element, scaleFactor, style, window) {\n            var result = {};\n            var pxScaleFactor = 96 / 72;\n            var backgroundColor = parseColor(element, function (elem) {\n              return window.getComputedStyle(elem)['backgroundColor'];\n            });\n            if (backgroundColor != null) result.fillColor = backgroundColor;\n            var textColor = parseColor(element, function (elem) {\n              return window.getComputedStyle(elem)['color'];\n            });\n            if (textColor != null) result.textColor = textColor;\n            var borderColor = parseColor(element, function (elem) {\n              return window.getComputedStyle(elem)['borderTopColor'];\n            });\n            if (borderColor != null) result.lineColor = borderColor;\n            var padding = parsePadding(style, scaleFactor);\n            if (padding) result.cellPadding = padding;\n            // style.borderWidth only works in chrome (borderTopWidth etc works in firefox and ie as well)\n            var bw = parseInt(style.borderTopWidth || '');\n            bw = bw / pxScaleFactor / scaleFactor;\n            if (bw) result.lineWidth = bw;\n            var accepted = ['left', 'right', 'center', 'justify'];\n            if (accepted.indexOf(style.textAlign) !== -1) {\n              result.halign = style.textAlign;\n            }\n            accepted = ['middle', 'bottom', 'top'];\n            if (accepted.indexOf(style.verticalAlign) !== -1) {\n              result.valign = style.verticalAlign;\n            }\n            var res = parseInt(style.fontSize || '');\n            if (!isNaN(res)) result.fontSize = res / pxScaleFactor;\n            var fontStyle = parseFontStyle(style);\n            if (fontStyle) result.fontStyle = fontStyle;\n            var font = (style.fontFamily || '').toLowerCase();\n            if (supportedFonts.indexOf(font) !== -1) {\n              result.font = font;\n            }\n            return result;\n          }\n          exports.parseCss = parseCss;\n          function parseFontStyle(style) {\n            var res = '';\n            if (style.fontWeight === 'bold' || style.fontWeight === 'bolder' || parseInt(style.fontWeight) >= 700) {\n              res = 'bold';\n            }\n            if (style.fontStyle === 'italic' || style.fontStyle === 'oblique') {\n              res += 'italic';\n            }\n            return res;\n          }\n          function parseColor(element, styleGetter) {\n            var cssColor = realColor(element, styleGetter);\n            if (!cssColor) return null;\n            var rgba = cssColor.match(/^rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*(\\d*\\.?\\d*))?\\)$/);\n            if (!rgba || !Array.isArray(rgba)) {\n              return null;\n            }\n            var color = [parseInt(rgba[1]), parseInt(rgba[2]), parseInt(rgba[3])];\n            var alpha = parseInt(rgba[4]);\n            if (alpha === 0 || isNaN(color[0]) || isNaN(color[1]) || isNaN(color[2])) {\n              return null;\n            }\n            return color;\n          }\n          function realColor(elem, styleGetter) {\n            var bg = styleGetter(elem);\n            if (bg === 'rgba(0, 0, 0, 0)' || bg === 'transparent' || bg === 'initial' || bg === 'inherit') {\n              if (elem.parentElement == null) {\n                return null;\n              }\n              return realColor(elem.parentElement, styleGetter);\n            } else {\n              return bg;\n            }\n          }\n          function parsePadding(style, scaleFactor) {\n            var val = [style.paddingTop, style.paddingRight, style.paddingBottom, style.paddingLeft];\n            var pxScaleFactor = 96 / (72 / scaleFactor);\n            var linePadding = (parseInt(style.lineHeight) - parseInt(style.fontSize)) / scaleFactor / 2;\n            var inputPadding = val.map(function (n) {\n              return parseInt(n || '0') / pxScaleFactor;\n            });\n            var padding = (0, common_1.parseSpacing)(inputPadding, 0);\n            if (linePadding > padding.top) {\n              padding.top = linePadding;\n            }\n            if (linePadding > padding.bottom) {\n              padding.bottom = linePadding;\n            }\n            return padding;\n          }\n\n          /***/\n        },\n\n        /***/323: /***/function (__unused_webpack_module, exports) {\n          Object.defineProperty(exports, \"__esModule\", {\n            value: true\n          });\n          exports.DocHandler = void 0;\n          var globalDefaults = {};\n          var DocHandler = /** @class */function () {\n            function DocHandler(jsPDFDocument) {\n              this.jsPDFDocument = jsPDFDocument;\n              this.userStyles = {\n                // Black for versions of jspdf without getTextColor\n                textColor: jsPDFDocument.getTextColor ? this.jsPDFDocument.getTextColor() : 0,\n                fontSize: jsPDFDocument.internal.getFontSize(),\n                fontStyle: jsPDFDocument.internal.getFont().fontStyle,\n                font: jsPDFDocument.internal.getFont().fontName,\n                // 0 for versions of jspdf without getLineWidth\n                lineWidth: jsPDFDocument.getLineWidth ? this.jsPDFDocument.getLineWidth() : 0,\n                // Black for versions of jspdf without getDrawColor\n                lineColor: jsPDFDocument.getDrawColor ? this.jsPDFDocument.getDrawColor() : 0\n              };\n            }\n            DocHandler.setDefaults = function (defaults, doc) {\n              if (doc === void 0) {\n                doc = null;\n              }\n              if (doc) {\n                doc.__autoTableDocumentDefaults = defaults;\n              } else {\n                globalDefaults = defaults;\n              }\n            };\n            DocHandler.unifyColor = function (c) {\n              if (Array.isArray(c)) {\n                return c;\n              } else if (typeof c === 'number') {\n                return [c, c, c];\n              } else if (typeof c === 'string') {\n                return [c];\n              } else {\n                return null;\n              }\n            };\n            DocHandler.prototype.applyStyles = function (styles, fontOnly) {\n              // Font style needs to be applied before font\n              // https://github.com/simonbengtsson/jsPDF-AutoTable/issues/632\n              var _a, _b, _c;\n              if (fontOnly === void 0) {\n                fontOnly = false;\n              }\n              if (styles.fontStyle) this.jsPDFDocument.setFontStyle && this.jsPDFDocument.setFontStyle(styles.fontStyle);\n              var _d = this.jsPDFDocument.internal.getFont(),\n                fontStyle = _d.fontStyle,\n                fontName = _d.fontName;\n              if (styles.font) fontName = styles.font;\n              if (styles.fontStyle) {\n                fontStyle = styles.fontStyle;\n                var availableFontStyles = this.getFontList()[fontName];\n                if (availableFontStyles && availableFontStyles.indexOf(fontStyle) === -1) {\n                  // Common issue was that the default bold in headers\n                  // made custom fonts not work. For example:\n                  // https://github.com/simonbengtsson/jsPDF-AutoTable/issues/653\n                  this.jsPDFDocument.setFontStyle && this.jsPDFDocument.setFontStyle(availableFontStyles[0]);\n                  fontStyle = availableFontStyles[0];\n                }\n              }\n              this.jsPDFDocument.setFont(fontName, fontStyle);\n              if (styles.fontSize) this.jsPDFDocument.setFontSize(styles.fontSize);\n              if (fontOnly) {\n                return; // Performance improvement\n              }\n\n              var color = DocHandler.unifyColor(styles.fillColor);\n              if (color) (_a = this.jsPDFDocument).setFillColor.apply(_a, color);\n              color = DocHandler.unifyColor(styles.textColor);\n              if (color) (_b = this.jsPDFDocument).setTextColor.apply(_b, color);\n              color = DocHandler.unifyColor(styles.lineColor);\n              if (color) (_c = this.jsPDFDocument).setDrawColor.apply(_c, color);\n              if (typeof styles.lineWidth === 'number') {\n                this.jsPDFDocument.setLineWidth(styles.lineWidth);\n              }\n            };\n            DocHandler.prototype.splitTextToSize = function (text, size, opts) {\n              return this.jsPDFDocument.splitTextToSize(text, size, opts);\n            };\n            DocHandler.prototype.rect = function (x, y, width, height, fillStyle) {\n              return this.jsPDFDocument.rect(x, y, width, height, fillStyle);\n            };\n            DocHandler.prototype.getLastAutoTable = function () {\n              return this.jsPDFDocument.lastAutoTable || null;\n            };\n            DocHandler.prototype.getTextWidth = function (text) {\n              return this.jsPDFDocument.getTextWidth(text);\n            };\n            DocHandler.prototype.getDocument = function () {\n              return this.jsPDFDocument;\n            };\n            DocHandler.prototype.setPage = function (page) {\n              this.jsPDFDocument.setPage(page);\n            };\n            DocHandler.prototype.addPage = function () {\n              return this.jsPDFDocument.addPage();\n            };\n            DocHandler.prototype.getFontList = function () {\n              return this.jsPDFDocument.getFontList();\n            };\n            DocHandler.prototype.getGlobalOptions = function () {\n              return globalDefaults || {};\n            };\n            DocHandler.prototype.getDocumentOptions = function () {\n              return this.jsPDFDocument.__autoTableDocumentDefaults || {};\n            };\n            DocHandler.prototype.pageSize = function () {\n              var pageSize = this.jsPDFDocument.internal.pageSize;\n              // JSPDF 1.4 uses get functions instead of properties on pageSize\n              if (pageSize.width == null) {\n                pageSize = {\n                  width: pageSize.getWidth(),\n                  height: pageSize.getHeight()\n                };\n              }\n              return pageSize;\n            };\n            DocHandler.prototype.scaleFactor = function () {\n              return this.jsPDFDocument.internal.scaleFactor;\n            };\n            DocHandler.prototype.pageNumber = function () {\n              var pageInfo = this.jsPDFDocument.internal.getCurrentPageInfo();\n              if (!pageInfo) {\n                // Only recent versions of jspdf has pageInfo\n                return this.jsPDFDocument.internal.getNumberOfPages();\n              }\n              return pageInfo.pageNumber;\n            };\n            return DocHandler;\n          }();\n          exports.DocHandler = DocHandler;\n\n          /***/\n        },\n\n        /***/148: /***/function (__unused_webpack_module, exports, __webpack_require__) {\n          Object.defineProperty(exports, \"__esModule\", {\n            value: true\n          });\n          exports.parseHtml = void 0;\n          var cssParser_1 = __webpack_require__(259);\n          var config_1 = __webpack_require__(913);\n          function parseHtml(doc, input, window, includeHiddenHtml, useCss) {\n            var _a, _b;\n            if (includeHiddenHtml === void 0) {\n              includeHiddenHtml = false;\n            }\n            if (useCss === void 0) {\n              useCss = false;\n            }\n            var tableElement;\n            if (typeof input === 'string') {\n              tableElement = window.document.querySelector(input);\n            } else {\n              tableElement = input;\n            }\n            var supportedFonts = Object.keys(doc.getFontList());\n            var scaleFactor = doc.scaleFactor();\n            var head = [],\n              body = [],\n              foot = [];\n            if (!tableElement) {\n              console.error('Html table could not be found with input: ', input);\n              return {\n                head: head,\n                body: body,\n                foot: foot\n              };\n            }\n            for (var i = 0; i < tableElement.rows.length; i++) {\n              var element = tableElement.rows[i];\n              var tagName = (_b = (_a = element === null || element === void 0 ? void 0 : element.parentElement) === null || _a === void 0 ? void 0 : _a.tagName) === null || _b === void 0 ? void 0 : _b.toLowerCase();\n              var row = parseRowContent(supportedFonts, scaleFactor, window, element, includeHiddenHtml, useCss);\n              if (!row) continue;\n              if (tagName === 'thead') {\n                head.push(row);\n              } else if (tagName === 'tfoot') {\n                foot.push(row);\n              } else {\n                // Add to body both if parent is tbody or table\n                body.push(row);\n              }\n            }\n            return {\n              head: head,\n              body: body,\n              foot: foot\n            };\n          }\n          exports.parseHtml = parseHtml;\n          function parseRowContent(supportedFonts, scaleFactor, window, row, includeHidden, useCss) {\n            var resultRow = new config_1.HtmlRowInput(row);\n            for (var i = 0; i < row.cells.length; i++) {\n              var cell = row.cells[i];\n              var style_1 = window.getComputedStyle(cell);\n              if (includeHidden || style_1.display !== 'none') {\n                var cellStyles = void 0;\n                if (useCss) {\n                  cellStyles = (0, cssParser_1.parseCss)(supportedFonts, cell, scaleFactor, style_1, window);\n                }\n                resultRow.push({\n                  rowSpan: cell.rowSpan,\n                  colSpan: cell.colSpan,\n                  styles: cellStyles,\n                  _element: cell,\n                  content: parseCellContent(cell)\n                });\n              }\n            }\n            var style = window.getComputedStyle(row);\n            if (resultRow.length > 0 && (includeHidden || style.display !== 'none')) {\n              return resultRow;\n            }\n          }\n          function parseCellContent(orgCell) {\n            // Work on cloned node to make sure no changes are applied to html table\n            var cell = orgCell.cloneNode(true);\n            // Remove extra space and line breaks in markup to make it more similar to\n            // what would be shown in html\n            cell.innerHTML = cell.innerHTML.replace(/\\n/g, '').replace(/ +/g, ' ');\n            // Preserve <br> tags as line breaks in the pdf\n            cell.innerHTML = cell.innerHTML.split(/\\<br.*?\\>/) //start with '<br' and ends with '>'.\n            .map(function (part) {\n              return part.trim();\n            }).join('\\n');\n            // innerText for ie\n            return cell.innerText || cell.textContent || '';\n          }\n\n          /***/\n        },\n\n        /***/587: /***/function (__unused_webpack_module, exports, __webpack_require__) {\n          Object.defineProperty(exports, \"__esModule\", {\n            value: true\n          });\n          exports.parseInput = void 0;\n          var htmlParser_1 = __webpack_require__(148);\n          var polyfills_1 = __webpack_require__(360);\n          var common_1 = __webpack_require__(200);\n          var documentHandler_1 = __webpack_require__(323);\n          var inputValidator_1 = __webpack_require__(291);\n          function parseInput(d, current) {\n            var doc = new documentHandler_1.DocHandler(d);\n            var document = doc.getDocumentOptions();\n            var global = doc.getGlobalOptions();\n            (0, inputValidator_1.default)(doc, global, document, current);\n            var options = (0, polyfills_1.assign)({}, global, document, current);\n            var win;\n            if (typeof window !== 'undefined') {\n              win = window;\n            }\n            var styles = parseStyles(global, document, current);\n            var hooks = parseHooks(global, document, current);\n            var settings = parseSettings(doc, options);\n            var content = parseContent(doc, options, win);\n            return {\n              id: current.tableId,\n              content: content,\n              hooks: hooks,\n              styles: styles,\n              settings: settings\n            };\n          }\n          exports.parseInput = parseInput;\n          function parseStyles(gInput, dInput, cInput) {\n            var styleOptions = {\n              styles: {},\n              headStyles: {},\n              bodyStyles: {},\n              footStyles: {},\n              alternateRowStyles: {},\n              columnStyles: {}\n            };\n            var _loop_1 = function (prop) {\n              if (prop === 'columnStyles') {\n                var global_1 = gInput[prop];\n                var document_1 = dInput[prop];\n                var current = cInput[prop];\n                styleOptions.columnStyles = (0, polyfills_1.assign)({}, global_1, document_1, current);\n              } else {\n                var allOptions = [gInput, dInput, cInput];\n                var styles = allOptions.map(function (opts) {\n                  return opts[prop] || {};\n                });\n                styleOptions[prop] = (0, polyfills_1.assign)({}, styles[0], styles[1], styles[2]);\n              }\n            };\n            for (var _i = 0, _a = Object.keys(styleOptions); _i < _a.length; _i++) {\n              var prop = _a[_i];\n              _loop_1(prop);\n            }\n            return styleOptions;\n          }\n          function parseHooks(global, document, current) {\n            var allOptions = [global, document, current];\n            var result = {\n              didParseCell: [],\n              willDrawCell: [],\n              didDrawCell: [],\n              didDrawPage: []\n            };\n            for (var _i = 0, allOptions_1 = allOptions; _i < allOptions_1.length; _i++) {\n              var options = allOptions_1[_i];\n              if (options.didParseCell) result.didParseCell.push(options.didParseCell);\n              if (options.willDrawCell) result.willDrawCell.push(options.willDrawCell);\n              if (options.didDrawCell) result.didDrawCell.push(options.didDrawCell);\n              if (options.didDrawPage) result.didDrawPage.push(options.didDrawPage);\n            }\n            return result;\n          }\n          function parseSettings(doc, options) {\n            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n            var margin = (0, common_1.parseSpacing)(options.margin, 40 / doc.scaleFactor());\n            var startY = (_a = getStartY(doc, options.startY)) !== null && _a !== void 0 ? _a : margin.top;\n            var showFoot;\n            if (options.showFoot === true) {\n              showFoot = 'everyPage';\n            } else if (options.showFoot === false) {\n              showFoot = 'never';\n            } else {\n              showFoot = (_b = options.showFoot) !== null && _b !== void 0 ? _b : 'everyPage';\n            }\n            var showHead;\n            if (options.showHead === true) {\n              showHead = 'everyPage';\n            } else if (options.showHead === false) {\n              showHead = 'never';\n            } else {\n              showHead = (_c = options.showHead) !== null && _c !== void 0 ? _c : 'everyPage';\n            }\n            var useCss = (_d = options.useCss) !== null && _d !== void 0 ? _d : false;\n            var theme = options.theme || (useCss ? 'plain' : 'striped');\n            var horizontalPageBreak = options.horizontalPageBreak ? true : false;\n            var horizontalPageBreakRepeat = (_e = options.horizontalPageBreakRepeat) !== null && _e !== void 0 ? _e : null;\n            return {\n              includeHiddenHtml: (_f = options.includeHiddenHtml) !== null && _f !== void 0 ? _f : false,\n              useCss: useCss,\n              theme: theme,\n              startY: startY,\n              margin: margin,\n              pageBreak: (_g = options.pageBreak) !== null && _g !== void 0 ? _g : 'auto',\n              rowPageBreak: (_h = options.rowPageBreak) !== null && _h !== void 0 ? _h : 'auto',\n              tableWidth: (_j = options.tableWidth) !== null && _j !== void 0 ? _j : 'auto',\n              showHead: showHead,\n              showFoot: showFoot,\n              tableLineWidth: (_k = options.tableLineWidth) !== null && _k !== void 0 ? _k : 0,\n              tableLineColor: (_l = options.tableLineColor) !== null && _l !== void 0 ? _l : 200,\n              horizontalPageBreak: horizontalPageBreak,\n              horizontalPageBreakRepeat: horizontalPageBreakRepeat\n            };\n          }\n          function getStartY(doc, userStartY) {\n            var previous = doc.getLastAutoTable();\n            var sf = doc.scaleFactor();\n            var currentPage = doc.pageNumber();\n            var isSamePageAsPreviousTable = false;\n            if (previous && previous.startPageNumber) {\n              var endingPage = previous.startPageNumber + previous.pageNumber - 1;\n              isSamePageAsPreviousTable = endingPage === currentPage;\n            }\n            if (typeof userStartY === 'number') {\n              return userStartY;\n            } else if (userStartY == null || userStartY === false) {\n              if (isSamePageAsPreviousTable && (previous === null || previous === void 0 ? void 0 : previous.finalY) != null) {\n                // Some users had issues with overlapping tables when they used multiple\n                // tables without setting startY so setting it here to a sensible default.\n                return previous.finalY + 20 / sf;\n              }\n            }\n            return null;\n          }\n          function parseContent(doc, options, window) {\n            var head = options.head || [];\n            var body = options.body || [];\n            var foot = options.foot || [];\n            if (options.html) {\n              var hidden = options.includeHiddenHtml;\n              if (window) {\n                var htmlContent = (0, htmlParser_1.parseHtml)(doc, options.html, window, hidden, options.useCss) || {};\n                head = htmlContent.head || head;\n                body = htmlContent.body || head;\n                foot = htmlContent.foot || head;\n              } else {\n                console.error('Cannot parse html in non browser environment');\n              }\n            }\n            var columns = options.columns || parseColumns(head, body, foot);\n            return {\n              columns: columns,\n              head: head,\n              body: body,\n              foot: foot\n            };\n          }\n          function parseColumns(head, body, foot) {\n            var firstRow = head[0] || body[0] || foot[0] || [];\n            var result = [];\n            Object.keys(firstRow).filter(function (key) {\n              return key !== '_element';\n            }).forEach(function (key) {\n              var colSpan = 1;\n              var input;\n              if (Array.isArray(firstRow)) {\n                input = firstRow[parseInt(key)];\n              } else {\n                input = firstRow[key];\n              }\n              if (typeof input === 'object' && !Array.isArray(input)) {\n                colSpan = (input === null || input === void 0 ? void 0 : input.colSpan) || 1;\n              }\n              for (var i = 0; i < colSpan; i++) {\n                var id = void 0;\n                if (Array.isArray(firstRow)) {\n                  id = result.length;\n                } else {\n                  id = key + (i > 0 ? \"_\".concat(i) : '');\n                }\n                var rowResult = {\n                  dataKey: id\n                };\n                result.push(rowResult);\n              }\n            });\n            return result;\n          }\n\n          /***/\n        },\n\n        /***/291: /***/function (__unused_webpack_module, exports) {\n          Object.defineProperty(exports, \"__esModule\", {\n            value: true\n          });\n          function default_1(doc, global, document, current) {\n            var _loop_1 = function (options) {\n              if (options && typeof options !== 'object') {\n                console.error('The options parameter should be of type object, is: ' + typeof options);\n              }\n              if (typeof options.extendWidth !== 'undefined') {\n                options.tableWidth = options.extendWidth ? 'auto' : 'wrap';\n                console.error('Use of deprecated option: extendWidth, use tableWidth instead.');\n              }\n              if (typeof options.margins !== 'undefined') {\n                if (typeof options.margin === 'undefined') options.margin = options.margins;\n                console.error('Use of deprecated option: margins, use margin instead.');\n              }\n              if (options.startY && typeof options.startY !== 'number') {\n                console.error('Invalid value for startY option', options.startY);\n                delete options.startY;\n              }\n              if (!options.didDrawPage && (options.afterPageContent || options.beforePageContent || options.afterPageAdd)) {\n                console.error('The afterPageContent, beforePageContent and afterPageAdd hooks are deprecated. Use didDrawPage instead');\n                options.didDrawPage = function (data) {\n                  doc.applyStyles(doc.userStyles);\n                  if (options.beforePageContent) options.beforePageContent(data);\n                  doc.applyStyles(doc.userStyles);\n                  if (options.afterPageContent) options.afterPageContent(data);\n                  doc.applyStyles(doc.userStyles);\n                  if (options.afterPageAdd && data.pageNumber > 1) {\n                    ;\n                    data.afterPageAdd(data);\n                  }\n                  doc.applyStyles(doc.userStyles);\n                };\n              }\n              ;\n              ['createdHeaderCell', 'drawHeaderRow', 'drawRow', 'drawHeaderCell'].forEach(function (name) {\n                if (options[name]) {\n                  console.error(\"The \\\"\".concat(name, \"\\\" hook has changed in version 3.0, check the changelog for how to migrate.\"));\n                }\n              });\n              [['showFoot', 'showFooter'], ['showHead', 'showHeader'], ['didDrawPage', 'addPageContent'], ['didParseCell', 'createdCell'], ['headStyles', 'headerStyles']].forEach(function (_a) {\n                var current = _a[0],\n                  deprecated = _a[1];\n                if (options[deprecated]) {\n                  console.error(\"Use of deprecated option \".concat(deprecated, \". Use \").concat(current, \" instead\"));\n                  options[current] = options[deprecated];\n                }\n              });\n              [['padding', 'cellPadding'], ['lineHeight', 'rowHeight'], 'fontSize', 'overflow'].forEach(function (o) {\n                var deprecatedOption = typeof o === 'string' ? o : o[0];\n                var style = typeof o === 'string' ? o : o[1];\n                if (typeof options[deprecatedOption] !== 'undefined') {\n                  if (typeof options.styles[style] === 'undefined') {\n                    options.styles[style] = options[deprecatedOption];\n                  }\n                  console.error('Use of deprecated option: ' + deprecatedOption + ', use the style ' + style + ' instead.');\n                }\n              });\n              for (var _b = 0, _c = ['styles', 'bodyStyles', 'headStyles', 'footStyles']; _b < _c.length; _b++) {\n                var styleProp = _c[_b];\n                checkStyles(options[styleProp] || {});\n              }\n              var columnStyles = options['columnStyles'] || {};\n              for (var _d = 0, _e = Object.keys(columnStyles); _d < _e.length; _d++) {\n                var key = _e[_d];\n                checkStyles(columnStyles[key] || {});\n              }\n            };\n            for (var _i = 0, _a = [global, document, current]; _i < _a.length; _i++) {\n              var options = _a[_i];\n              _loop_1(options);\n            }\n          }\n          exports[\"default\"] = default_1;\n          function checkStyles(styles) {\n            if (styles.rowHeight) {\n              console.error('Use of deprecated style rowHeight. It is renamed to minCellHeight.');\n              if (!styles.minCellHeight) {\n                styles.minCellHeight = styles.rowHeight;\n              }\n            } else if (styles.columnWidth) {\n              console.error('Use of deprecated style columnWidth. It is renamed to cellWidth.');\n              if (!styles.cellWidth) {\n                styles.cellWidth = styles.columnWidth;\n              }\n            }\n          }\n\n          /***/\n        },\n\n        /***/287: /***/function (__unused_webpack_module, exports, __webpack_require__) {\n          Object.defineProperty(exports, \"__esModule\", {\n            value: true\n          });\n          exports.Column = exports.Cell = exports.Row = exports.Table = void 0;\n          var config_1 = __webpack_require__(913);\n          var HookData_1 = __webpack_require__(662);\n          var common_1 = __webpack_require__(200);\n          var Table = /** @class */function () {\n            function Table(input, content) {\n              this.pageNumber = 1;\n              // Deprecated, use pageNumber instead\n              // Not using getter since:\n              // https://github.com/simonbengtsson/jsPDF-AutoTable/issues/596\n              this.pageCount = 1;\n              this.id = input.id;\n              this.settings = input.settings;\n              this.styles = input.styles;\n              this.hooks = input.hooks;\n              this.columns = content.columns;\n              this.head = content.head;\n              this.body = content.body;\n              this.foot = content.foot;\n            }\n            Table.prototype.getHeadHeight = function (columns) {\n              return this.head.reduce(function (acc, row) {\n                return acc + row.getMaxCellHeight(columns);\n              }, 0);\n            };\n            Table.prototype.getFootHeight = function (columns) {\n              return this.foot.reduce(function (acc, row) {\n                return acc + row.getMaxCellHeight(columns);\n              }, 0);\n            };\n            Table.prototype.allRows = function () {\n              return this.head.concat(this.body).concat(this.foot);\n            };\n            Table.prototype.callCellHooks = function (doc, handlers, cell, row, column, cursor) {\n              for (var _i = 0, handlers_1 = handlers; _i < handlers_1.length; _i++) {\n                var handler = handlers_1[_i];\n                var data = new HookData_1.CellHookData(doc, this, cell, row, column, cursor);\n                var result = handler(data) === false;\n                // Make sure text is always string[] since user can assign string\n                cell.text = Array.isArray(cell.text) ? cell.text : [cell.text];\n                if (result) {\n                  return false;\n                }\n              }\n              return true;\n            };\n            Table.prototype.callEndPageHooks = function (doc, cursor) {\n              doc.applyStyles(doc.userStyles);\n              for (var _i = 0, _a = this.hooks.didDrawPage; _i < _a.length; _i++) {\n                var handler = _a[_i];\n                handler(new HookData_1.HookData(doc, this, cursor));\n              }\n            };\n            Table.prototype.getWidth = function (pageWidth) {\n              if (typeof this.settings.tableWidth === 'number') {\n                return this.settings.tableWidth;\n              } else if (this.settings.tableWidth === 'wrap') {\n                var wrappedWidth = this.columns.reduce(function (total, col) {\n                  return total + col.wrappedWidth;\n                }, 0);\n                return wrappedWidth;\n              } else {\n                var margin = this.settings.margin;\n                return pageWidth - margin.left - margin.right;\n              }\n            };\n            return Table;\n          }();\n          exports.Table = Table;\n          var Row = /** @class */function () {\n            function Row(raw, index, section, cells, spansMultiplePages) {\n              if (spansMultiplePages === void 0) {\n                spansMultiplePages = false;\n              }\n              this.height = 0;\n              this.raw = raw;\n              if (raw instanceof config_1.HtmlRowInput) {\n                this.raw = raw._element;\n                this.element = raw._element;\n              }\n              this.index = index;\n              this.section = section;\n              this.cells = cells;\n              this.spansMultiplePages = spansMultiplePages;\n            }\n            Row.prototype.getMaxCellHeight = function (columns) {\n              var _this = this;\n              return columns.reduce(function (acc, column) {\n                var _a;\n                return Math.max(acc, ((_a = _this.cells[column.index]) === null || _a === void 0 ? void 0 : _a.height) || 0);\n              }, 0);\n            };\n            Row.prototype.hasRowSpan = function (columns) {\n              var _this = this;\n              return columns.filter(function (column) {\n                var cell = _this.cells[column.index];\n                if (!cell) return false;\n                return cell.rowSpan > 1;\n              }).length > 0;\n            };\n            Row.prototype.canEntireRowFit = function (height, columns) {\n              return this.getMaxCellHeight(columns) <= height;\n            };\n            Row.prototype.getMinimumRowHeight = function (columns, doc) {\n              var _this = this;\n              return columns.reduce(function (acc, column) {\n                var cell = _this.cells[column.index];\n                if (!cell) return 0;\n                var fontHeight = cell.styles.fontSize / doc.scaleFactor() * config_1.FONT_ROW_RATIO;\n                var vPadding = cell.padding('vertical');\n                var oneRowHeight = vPadding + fontHeight;\n                return oneRowHeight > acc ? oneRowHeight : acc;\n              }, 0);\n            };\n            return Row;\n          }();\n          exports.Row = Row;\n          var Cell = /** @class */function () {\n            function Cell(raw, styles, section) {\n              var _a, _b;\n              this.contentHeight = 0;\n              this.contentWidth = 0;\n              this.wrappedWidth = 0;\n              this.minReadableWidth = 0;\n              this.minWidth = 0;\n              this.width = 0;\n              this.height = 0;\n              this.x = 0;\n              this.y = 0;\n              this.styles = styles;\n              this.section = section;\n              this.raw = raw;\n              var content = raw;\n              if (raw != null && typeof raw === 'object' && !Array.isArray(raw)) {\n                this.rowSpan = raw.rowSpan || 1;\n                this.colSpan = raw.colSpan || 1;\n                content = (_b = (_a = raw.content) !== null && _a !== void 0 ? _a : raw.title) !== null && _b !== void 0 ? _b : raw;\n                if (raw._element) {\n                  this.raw = raw._element;\n                }\n              } else {\n                this.rowSpan = 1;\n                this.colSpan = 1;\n              }\n              // Stringify 0 and false, but not undefined or null\n              var text = content != null ? '' + content : '';\n              var splitRegex = /\\r\\n|\\r|\\n/g;\n              this.text = text.split(splitRegex);\n            }\n            Cell.prototype.getTextPos = function () {\n              var y;\n              if (this.styles.valign === 'top') {\n                y = this.y + this.padding('top');\n              } else if (this.styles.valign === 'bottom') {\n                y = this.y + this.height - this.padding('bottom');\n              } else {\n                var netHeight = this.height - this.padding('vertical');\n                y = this.y + netHeight / 2 + this.padding('top');\n              }\n              var x;\n              if (this.styles.halign === 'right') {\n                x = this.x + this.width - this.padding('right');\n              } else if (this.styles.halign === 'center') {\n                var netWidth = this.width - this.padding('horizontal');\n                x = this.x + netWidth / 2 + this.padding('left');\n              } else {\n                x = this.x + this.padding('left');\n              }\n              return {\n                x: x,\n                y: y\n              };\n            };\n            Cell.prototype.getContentHeight = function (scaleFactor) {\n              var lineCount = Array.isArray(this.text) ? this.text.length : 1;\n              var fontHeight = this.styles.fontSize / scaleFactor * config_1.FONT_ROW_RATIO;\n              var height = lineCount * fontHeight + this.padding('vertical');\n              return Math.max(height, this.styles.minCellHeight);\n            };\n            Cell.prototype.padding = function (name) {\n              var padding = (0, common_1.parseSpacing)(this.styles.cellPadding, 0);\n              if (name === 'vertical') {\n                return padding.top + padding.bottom;\n              } else if (name === 'horizontal') {\n                return padding.left + padding.right;\n              } else {\n                return padding[name];\n              }\n            };\n            return Cell;\n          }();\n          exports.Cell = Cell;\n          var Column = /** @class */function () {\n            function Column(dataKey, raw, index) {\n              this.wrappedWidth = 0;\n              this.minReadableWidth = 0;\n              this.minWidth = 0;\n              this.width = 0;\n              this.dataKey = dataKey;\n              this.raw = raw;\n              this.index = index;\n            }\n            Column.prototype.getMaxCustomCellWidth = function (table) {\n              var max = 0;\n              for (var _i = 0, _a = table.allRows(); _i < _a.length; _i++) {\n                var row = _a[_i];\n                var cell = row.cells[this.index];\n                if (cell && typeof cell.styles.cellWidth === 'number') {\n                  max = Math.max(max, cell.styles.cellWidth);\n                }\n              }\n              return max;\n            };\n            return Column;\n          }();\n          exports.Column = Column;\n\n          /***/\n        },\n\n        /***/360: /***/function (__unused_webpack_module, exports) {\n          /* eslint-disable @typescript-eslint/no-unused-vars */\n          Object.defineProperty(exports, \"__esModule\", {\n            value: true\n          });\n          exports.assign = void 0;\n          // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n          function assign(target, s, s1, s2, s3) {\n            if (target == null) {\n              throw new TypeError('Cannot convert undefined or null to object');\n            }\n            var to = Object(target);\n            for (var index = 1; index < arguments.length; index++) {\n              // eslint-disable-next-line prefer-rest-params\n              var nextSource = arguments[index];\n              if (nextSource != null) {\n                // Skip over if undefined or null\n                for (var nextKey in nextSource) {\n                  // Avoid bugs when hasOwnProperty is shadowed\n                  if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n                    to[nextKey] = nextSource[nextKey];\n                  }\n                }\n              }\n            }\n            return to;\n          }\n          exports.assign = assign;\n\n          /***/\n        },\n\n        /***/858: /***/function (__unused_webpack_module, exports, __webpack_require__) {\n          Object.defineProperty(exports, \"__esModule\", {\n            value: true\n          });\n          exports.createTable = void 0;\n          var documentHandler_1 = __webpack_require__(323);\n          var models_1 = __webpack_require__(287);\n          var widthCalculator_1 = __webpack_require__(189);\n          var config_1 = __webpack_require__(913);\n          var polyfills_1 = __webpack_require__(360);\n          function createTable(jsPDFDoc, input) {\n            var doc = new documentHandler_1.DocHandler(jsPDFDoc);\n            var content = parseContent(input, doc.scaleFactor());\n            var table = new models_1.Table(input, content);\n            (0, widthCalculator_1.calculateWidths)(doc, table);\n            doc.applyStyles(doc.userStyles);\n            return table;\n          }\n          exports.createTable = createTable;\n          function parseContent(input, sf) {\n            var content = input.content;\n            var columns = createColumns(content.columns);\n            // If no head or foot is set, try generating it with content from columns\n            if (content.head.length === 0) {\n              var sectionRow = generateSectionRow(columns, 'head');\n              if (sectionRow) content.head.push(sectionRow);\n            }\n            if (content.foot.length === 0) {\n              var sectionRow = generateSectionRow(columns, 'foot');\n              if (sectionRow) content.foot.push(sectionRow);\n            }\n            var theme = input.settings.theme;\n            var styles = input.styles;\n            return {\n              columns: columns,\n              head: parseSection('head', content.head, columns, styles, theme, sf),\n              body: parseSection('body', content.body, columns, styles, theme, sf),\n              foot: parseSection('foot', content.foot, columns, styles, theme, sf)\n            };\n          }\n          function parseSection(sectionName, sectionRows, columns, styleProps, theme, scaleFactor) {\n            var rowSpansLeftForColumn = {};\n            var result = sectionRows.map(function (rawRow, rowIndex) {\n              var skippedRowForRowSpans = 0;\n              var cells = {};\n              var colSpansAdded = 0;\n              var columnSpansLeft = 0;\n              for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {\n                var column = columns_1[_i];\n                if (rowSpansLeftForColumn[column.index] == null || rowSpansLeftForColumn[column.index].left === 0) {\n                  if (columnSpansLeft === 0) {\n                    var rawCell = void 0;\n                    if (Array.isArray(rawRow)) {\n                      rawCell = rawRow[column.index - colSpansAdded - skippedRowForRowSpans];\n                    } else {\n                      rawCell = rawRow[column.dataKey];\n                    }\n                    var cellInputStyles = {};\n                    if (typeof rawCell === 'object' && !Array.isArray(rawCell)) {\n                      cellInputStyles = (rawCell === null || rawCell === void 0 ? void 0 : rawCell.styles) || {};\n                    }\n                    var styles = cellStyles(sectionName, column, rowIndex, theme, styleProps, scaleFactor, cellInputStyles);\n                    var cell = new models_1.Cell(rawCell, styles, sectionName);\n                    // dataKey is not used internally no more but keep for\n                    // backwards compat in hooks\n                    cells[column.dataKey] = cell;\n                    cells[column.index] = cell;\n                    columnSpansLeft = cell.colSpan - 1;\n                    rowSpansLeftForColumn[column.index] = {\n                      left: cell.rowSpan - 1,\n                      times: columnSpansLeft\n                    };\n                  } else {\n                    columnSpansLeft--;\n                    colSpansAdded++;\n                  }\n                } else {\n                  rowSpansLeftForColumn[column.index].left--;\n                  columnSpansLeft = rowSpansLeftForColumn[column.index].times;\n                  skippedRowForRowSpans++;\n                }\n              }\n              return new models_1.Row(rawRow, rowIndex, sectionName, cells);\n            });\n            return result;\n          }\n          function generateSectionRow(columns, section) {\n            var sectionRow = {};\n            columns.forEach(function (col) {\n              if (col.raw != null) {\n                var title = getSectionTitle(section, col.raw);\n                if (title != null) sectionRow[col.dataKey] = title;\n              }\n            });\n            return Object.keys(sectionRow).length > 0 ? sectionRow : null;\n          }\n          function getSectionTitle(section, column) {\n            if (section === 'head') {\n              if (typeof column === 'object') {\n                return column.header || column.title || null;\n              } else if (typeof column === 'string' || typeof column === 'number') {\n                return column;\n              }\n            } else if (section === 'foot' && typeof column === 'object') {\n              return column.footer;\n            }\n            return null;\n          }\n          function createColumns(columns) {\n            return columns.map(function (input, index) {\n              var _a, _b;\n              var key;\n              if (typeof input === 'object') {\n                key = (_b = (_a = input.dataKey) !== null && _a !== void 0 ? _a : input.key) !== null && _b !== void 0 ? _b : index;\n              } else {\n                key = index;\n              }\n              return new models_1.Column(key, input, index);\n            });\n          }\n          function cellStyles(sectionName, column, rowIndex, themeName, styles, scaleFactor, cellInputStyles) {\n            var theme = (0, config_1.getTheme)(themeName);\n            var sectionStyles;\n            if (sectionName === 'head') {\n              sectionStyles = styles.headStyles;\n            } else if (sectionName === 'body') {\n              sectionStyles = styles.bodyStyles;\n            } else if (sectionName === 'foot') {\n              sectionStyles = styles.footStyles;\n            }\n            var otherStyles = (0, polyfills_1.assign)({}, theme.table, theme[sectionName], styles.styles, sectionStyles);\n            var columnStyles = styles.columnStyles[column.dataKey] || styles.columnStyles[column.index] || {};\n            var colStyles = sectionName === 'body' ? columnStyles : {};\n            var rowStyles = sectionName === 'body' && rowIndex % 2 === 0 ? (0, polyfills_1.assign)({}, theme.alternateRow, styles.alternateRowStyles) : {};\n            var defaultStyle = (0, config_1.defaultStyles)(scaleFactor);\n            var themeStyles = (0, polyfills_1.assign)({}, defaultStyle, otherStyles, rowStyles, colStyles);\n            return (0, polyfills_1.assign)(themeStyles, cellInputStyles);\n          }\n\n          /***/\n        },\n\n        /***/49: /***/function (__unused_webpack_module, exports, __webpack_require__) {\n          var __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n            if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n              if (ar || !(i in from)) {\n                if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n                ar[i] = from[i];\n              }\n            }\n            return to.concat(ar || Array.prototype.slice.call(from));\n          };\n          Object.defineProperty(exports, \"__esModule\", {\n            value: true\n          });\n          exports.addPage = exports.drawTable = void 0;\n          var config_1 = __webpack_require__(913);\n          var common_1 = __webpack_require__(200);\n          var models_1 = __webpack_require__(287);\n          var documentHandler_1 = __webpack_require__(323);\n          var polyfills_1 = __webpack_require__(360);\n          var autoTableText_1 = __webpack_require__(938);\n          var tablePrinter_1 = __webpack_require__(435);\n          function drawTable(jsPDFDoc, table) {\n            var settings = table.settings;\n            var startY = settings.startY;\n            var margin = settings.margin;\n            var cursor = {\n              x: margin.left,\n              y: startY\n            };\n            var sectionsHeight = table.getHeadHeight(table.columns) + table.getFootHeight(table.columns);\n            var minTableBottomPos = startY + margin.bottom + sectionsHeight;\n            if (settings.pageBreak === 'avoid') {\n              var rows = table.allRows();\n              var tableHeight = rows.reduce(function (acc, row) {\n                return acc + row.height;\n              }, 0);\n              minTableBottomPos += tableHeight;\n            }\n            var doc = new documentHandler_1.DocHandler(jsPDFDoc);\n            if (settings.pageBreak === 'always' || settings.startY != null && minTableBottomPos > doc.pageSize().height) {\n              nextPage(doc);\n              cursor.y = margin.top;\n            }\n            var startPos = (0, polyfills_1.assign)({}, cursor);\n            table.startPageNumber = doc.pageNumber();\n            if (settings.horizontalPageBreak === true) {\n              // managed flow for split columns\n              printTableWithHorizontalPageBreak(doc, table, startPos, cursor);\n            } else {\n              // normal flow\n              doc.applyStyles(doc.userStyles);\n              if (settings.showHead === 'firstPage' || settings.showHead === 'everyPage') {\n                table.head.forEach(function (row) {\n                  return printRow(doc, table, row, cursor, table.columns);\n                });\n              }\n              doc.applyStyles(doc.userStyles);\n              table.body.forEach(function (row, index) {\n                var isLastRow = index === table.body.length - 1;\n                printFullRow(doc, table, row, isLastRow, startPos, cursor, table.columns);\n              });\n              doc.applyStyles(doc.userStyles);\n              if (settings.showFoot === 'lastPage' || settings.showFoot === 'everyPage') {\n                table.foot.forEach(function (row) {\n                  return printRow(doc, table, row, cursor, table.columns);\n                });\n              }\n            }\n            (0, common_1.addTableBorder)(doc, table, startPos, cursor);\n            table.callEndPageHooks(doc, cursor);\n            table.finalY = cursor.y;\n            jsPDFDoc.lastAutoTable = table;\n            jsPDFDoc.previousAutoTable = table; // Deprecated\n            if (jsPDFDoc.autoTable) jsPDFDoc.autoTable.previous = table; // Deprecated\n            doc.applyStyles(doc.userStyles);\n          }\n          exports.drawTable = drawTable;\n          function printTableWithHorizontalPageBreak(doc, table, startPos, cursor) {\n            // calculate width of columns and render only those which can fit into page\n            var allColumnsCanFitResult = tablePrinter_1.default.calculateAllColumnsCanFitInPage(doc, table);\n            allColumnsCanFitResult.map(function (colsAndIndexes, index) {\n              doc.applyStyles(doc.userStyles);\n              // add page to print next columns in new page\n              if (index > 0) {\n                addPage(doc, table, startPos, cursor, colsAndIndexes.columns);\n              } else {\n                // print head for selected columns\n                printHead(doc, table, cursor, colsAndIndexes.columns);\n              }\n              // print body for selected columns\n              printBody(doc, table, startPos, cursor, colsAndIndexes.columns);\n              // print foot for selected columns\n              printFoot(doc, table, cursor, colsAndIndexes.columns);\n            });\n          }\n          function printHead(doc, table, cursor, columns) {\n            var settings = table.settings;\n            doc.applyStyles(doc.userStyles);\n            if (settings.showHead === 'firstPage' || settings.showHead === 'everyPage') {\n              table.head.forEach(function (row) {\n                return printRow(doc, table, row, cursor, columns);\n              });\n            }\n          }\n          function printBody(doc, table, startPos, cursor, columns) {\n            doc.applyStyles(doc.userStyles);\n            table.body.forEach(function (row, index) {\n              var isLastRow = index === table.body.length - 1;\n              printFullRow(doc, table, row, isLastRow, startPos, cursor, columns);\n            });\n          }\n          function printFoot(doc, table, cursor, columns) {\n            var settings = table.settings;\n            doc.applyStyles(doc.userStyles);\n            if (settings.showFoot === 'lastPage' || settings.showFoot === 'everyPage') {\n              table.foot.forEach(function (row) {\n                return printRow(doc, table, row, cursor, columns);\n              });\n            }\n          }\n          function getRemainingLineCount(cell, remainingPageSpace, doc) {\n            var fontHeight = cell.styles.fontSize / doc.scaleFactor() * config_1.FONT_ROW_RATIO;\n            var vPadding = cell.padding('vertical');\n            var remainingLines = Math.floor((remainingPageSpace - vPadding) / fontHeight);\n            return Math.max(0, remainingLines);\n          }\n          function modifyRowToFit(row, remainingPageSpace, table, doc) {\n            var cells = {};\n            row.spansMultiplePages = true;\n            row.height = 0;\n            var rowHeight = 0;\n            for (var _i = 0, _a = table.columns; _i < _a.length; _i++) {\n              var column = _a[_i];\n              var cell = row.cells[column.index];\n              if (!cell) continue;\n              if (!Array.isArray(cell.text)) {\n                cell.text = [cell.text];\n              }\n              var remainderCell = new models_1.Cell(cell.raw, cell.styles, cell.section);\n              remainderCell = (0, polyfills_1.assign)(remainderCell, cell);\n              remainderCell.text = [];\n              var remainingLineCount = getRemainingLineCount(cell, remainingPageSpace, doc);\n              if (cell.text.length > remainingLineCount) {\n                remainderCell.text = cell.text.splice(remainingLineCount, cell.text.length);\n              }\n              var scaleFactor = doc.scaleFactor();\n              cell.contentHeight = cell.getContentHeight(scaleFactor);\n              if (cell.contentHeight >= remainingPageSpace) {\n                cell.contentHeight = remainingPageSpace;\n                remainderCell.styles.minCellHeight -= remainingPageSpace;\n              }\n              if (cell.contentHeight > row.height) {\n                row.height = cell.contentHeight;\n              }\n              remainderCell.contentHeight = remainderCell.getContentHeight(scaleFactor);\n              if (remainderCell.contentHeight > rowHeight) {\n                rowHeight = remainderCell.contentHeight;\n              }\n              cells[column.index] = remainderCell;\n            }\n            var remainderRow = new models_1.Row(row.raw, -1, row.section, cells, true);\n            remainderRow.height = rowHeight;\n            for (var _b = 0, _c = table.columns; _b < _c.length; _b++) {\n              var column = _c[_b];\n              var remainderCell = remainderRow.cells[column.index];\n              if (remainderCell) {\n                remainderCell.height = remainderRow.height;\n              }\n              var cell = row.cells[column.index];\n              if (cell) {\n                cell.height = row.height;\n              }\n            }\n            return remainderRow;\n          }\n          function shouldPrintOnCurrentPage(doc, row, remainingPageSpace, table) {\n            var pageHeight = doc.pageSize().height;\n            var margin = table.settings.margin;\n            var marginHeight = margin.top + margin.bottom;\n            var maxRowHeight = pageHeight - marginHeight;\n            if (row.section === 'body') {\n              // Should also take into account that head and foot is not\n              // on every page with some settings\n              maxRowHeight -= table.getHeadHeight(table.columns) + table.getFootHeight(table.columns);\n            }\n            var minRowHeight = row.getMinimumRowHeight(table.columns, doc);\n            var minRowFits = minRowHeight < remainingPageSpace;\n            if (minRowHeight > maxRowHeight) {\n              console.error(\"Will not be able to print row \".concat(row.index, \" correctly since it's minimum height is larger than page height\"));\n              return true;\n            }\n            if (!minRowFits) {\n              return false;\n            }\n            var rowHasRowSpanCell = row.hasRowSpan(table.columns);\n            var rowHigherThanPage = row.getMaxCellHeight(table.columns) > maxRowHeight;\n            if (rowHigherThanPage) {\n              if (rowHasRowSpanCell) {\n                console.error(\"The content of row \".concat(row.index, \" will not be drawn correctly since drawing rows with a height larger than the page height and has cells with rowspans is not supported.\"));\n              }\n              return true;\n            }\n            if (rowHasRowSpanCell) {\n              // Currently a new page is required whenever a rowspan row don't fit a page.\n              return false;\n            }\n            if (table.settings.rowPageBreak === 'avoid') {\n              return false;\n            }\n            // In all other cases print the row on current page\n            return true;\n          }\n          function printFullRow(doc, table, row, isLastRow, startPos, cursor, columns) {\n            var remainingSpace = getRemainingPageSpace(doc, table, isLastRow, cursor);\n            if (row.canEntireRowFit(remainingSpace, columns)) {\n              printRow(doc, table, row, cursor, columns);\n            } else {\n              if (shouldPrintOnCurrentPage(doc, row, remainingSpace, table)) {\n                var remainderRow = modifyRowToFit(row, remainingSpace, table, doc);\n                printRow(doc, table, row, cursor, columns);\n                addPage(doc, table, startPos, cursor, columns);\n                printFullRow(doc, table, remainderRow, isLastRow, startPos, cursor, columns);\n              } else {\n                addPage(doc, table, startPos, cursor, columns);\n                printFullRow(doc, table, row, isLastRow, startPos, cursor, columns);\n              }\n            }\n          }\n          function printRow(doc, table, row, cursor, columns) {\n            cursor.x = table.settings.margin.left;\n            for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {\n              var column = columns_1[_i];\n              var cell = row.cells[column.index];\n              if (!cell) {\n                cursor.x += column.width;\n                continue;\n              }\n              doc.applyStyles(cell.styles);\n              cell.x = cursor.x;\n              cell.y = cursor.y;\n              var result = table.callCellHooks(doc, table.hooks.willDrawCell, cell, row, column, cursor);\n              if (result === false) {\n                cursor.x += column.width;\n                continue;\n              }\n              drawCellBorders(doc, cell, cursor);\n              var textPos = cell.getTextPos();\n              (0, autoTableText_1.default)(cell.text, textPos.x, textPos.y, {\n                halign: cell.styles.halign,\n                valign: cell.styles.valign,\n                maxWidth: Math.ceil(cell.width - cell.padding('left') - cell.padding('right'))\n              }, doc.getDocument());\n              table.callCellHooks(doc, table.hooks.didDrawCell, cell, row, column, cursor);\n              cursor.x += column.width;\n            }\n            cursor.y += row.height;\n          }\n          function drawCellBorders(doc, cell, cursor) {\n            var cellStyles = cell.styles;\n            doc.getDocument().setFillColor(doc.getDocument().getFillColor());\n            if (typeof cellStyles.lineWidth === 'number') {\n              // prints normal cell border using rect's stroke\n              var fillStyle = (0, common_1.getFillStyle)(cellStyles.lineWidth, cellStyles.fillColor);\n              if (fillStyle) {\n                doc.rect(cell.x, cursor.y, cell.width, cell.height, fillStyle);\n              }\n            } else if (typeof cellStyles.lineWidth === 'object') {\n              drawCellBackground(doc, cell, cursor, cellStyles.fillColor);\n              drawBorders(doc, cell, cursor, cellStyles.fillColor, cellStyles.lineWidth);\n            }\n          }\n          /**\n           * Prints cell background without borders and allows transparent color.\n           * @param doc\n           * @param cell\n           * @param cursor\n           * @param fillColor - `false` for transparent, `string` for color, other types will use \"F\" from jsPDF.rect\n           */\n          function drawCellBackground(doc, cell, cursor, fillColor) {\n            var cellFillColor = fillColor === false ? null : typeof fillColor !== 'string' ? 'F' : fillColor;\n            doc.rect(cell.x, cursor.y, cell.width, cell.height, cellFillColor);\n          }\n          /**\n           * Draw all specified borders. Borders are centered on cell's edge and lengthened\n           * to overlap with neighbours to create sharp corners.\n           * @param doc\n           * @param cell\n           * @param cursor\n           * @param fillColor\n           * @param lineWidth\n           */\n          function drawBorders(doc, cell, cursor, fillColor, lineWidth) {\n            var x1, y1, x2, y2;\n            if (lineWidth.top) {\n              x1 = cursor.x;\n              y1 = cursor.y;\n              x2 = cursor.x + cell.width;\n              y2 = cursor.y;\n              if (lineWidth.right) {\n                x2 += 0.5 * lineWidth.right;\n              }\n              if (lineWidth.left) {\n                x1 -= 0.5 * lineWidth.left;\n              }\n              drawLine([x1, y1, x2, y2], lineWidth.top, fillColor);\n            }\n            if (lineWidth.bottom) {\n              x1 = cursor.x;\n              y1 = cursor.y + cell.height;\n              x2 = cursor.x + cell.width;\n              y2 = cursor.y + cell.height;\n              if (lineWidth.right) {\n                x2 += 0.5 * lineWidth.right;\n              }\n              if (lineWidth.left) {\n                x1 -= 0.5 * lineWidth.left;\n              }\n              drawLine([x1, y1, x2, y2], lineWidth.bottom, fillColor);\n            }\n            if (lineWidth.left) {\n              x1 = cursor.x;\n              y1 = cursor.y;\n              x2 = cursor.x;\n              y2 = cursor.y + cell.height;\n              if (lineWidth.top) {\n                y1 -= 0.5 * lineWidth.top;\n              }\n              if (lineWidth.bottom) {\n                y2 += 0.5 * lineWidth.bottom;\n              }\n              drawLine([x1, y1, x2, y2], lineWidth.left, fillColor);\n            }\n            if (lineWidth.right) {\n              x1 = cursor.x + cell.width;\n              y1 = cursor.y;\n              x2 = cursor.x + cell.width;\n              y2 = cursor.y + cell.height;\n              if (lineWidth.top) {\n                y1 -= 0.5 * lineWidth.top;\n              }\n              if (lineWidth.bottom) {\n                y2 += 0.5 * lineWidth.bottom;\n              }\n              drawLine([x1, y1, x2, y2], lineWidth.right, fillColor);\n            }\n            function drawLine(coords, width, color) {\n              var _a;\n              doc.getDocument().setLineWidth(width);\n              (_a = doc.getDocument()).line.apply(_a, __spreadArray(__spreadArray([], coords, false), [(0, common_1.getFillStyle)(width, color)], false));\n            }\n          }\n          function getRemainingPageSpace(doc, table, isLastRow, cursor) {\n            var bottomContentHeight = table.settings.margin.bottom;\n            var showFoot = table.settings.showFoot;\n            if (showFoot === 'everyPage' || showFoot === 'lastPage' && isLastRow) {\n              bottomContentHeight += table.getFootHeight(table.columns);\n            }\n            return doc.pageSize().height - cursor.y - bottomContentHeight;\n          }\n          function addPage(doc, table, startPos, cursor, columns) {\n            if (columns === void 0) {\n              columns = [];\n            }\n            doc.applyStyles(doc.userStyles);\n            if (table.settings.showFoot === 'everyPage') {\n              table.foot.forEach(function (row) {\n                return printRow(doc, table, row, cursor, columns);\n              });\n            }\n            // Add user content just before adding new page ensure it will\n            // be drawn above other things on the page\n            table.callEndPageHooks(doc, cursor);\n            var margin = table.settings.margin;\n            (0, common_1.addTableBorder)(doc, table, startPos, cursor);\n            nextPage(doc);\n            table.pageNumber++;\n            table.pageCount++;\n            cursor.x = margin.left;\n            cursor.y = margin.top;\n            startPos.y = margin.top;\n            if (table.settings.showHead === 'everyPage') {\n              table.head.forEach(function (row) {\n                return printRow(doc, table, row, cursor, columns);\n              });\n              doc.applyStyles(doc.userStyles);\n            }\n          }\n          exports.addPage = addPage;\n          function nextPage(doc) {\n            var current = doc.pageNumber();\n            doc.setPage(current + 1);\n            var newCurrent = doc.pageNumber();\n            if (newCurrent === current) {\n              doc.addPage();\n            }\n          }\n\n          /***/\n        },\n\n        /***/435: /***/function (__unused_webpack_module, exports, __webpack_require__) {\n          Object.defineProperty(exports, \"__esModule\", {\n            value: true\n          });\n          var common_1 = __webpack_require__(200);\n          var getPageAvailableWidth = function (doc, table) {\n            var margins = (0, common_1.parseSpacing)(table.settings.margin, 0);\n            var availablePageWidth = doc.pageSize().width - (margins.left + margins.right);\n            return availablePageWidth;\n          };\n          // get columns can be fit into page\n          var getColumnsCanFitInPage = function (doc, table, config) {\n            if (config === void 0) {\n              config = {};\n            }\n            // get page width\n            var availablePageWidth = getPageAvailableWidth(doc, table);\n            var remainingWidth = availablePageWidth;\n            // get column data key to repeat\n            var horizontalPageBreakRepeat = table.settings.horizontalPageBreakRepeat;\n            var repeatColumn = null;\n            var cols = [];\n            var columns = [];\n            var len = table.columns.length;\n            var i = config && config.start ? config.start : 0;\n            // code to repeat the given column in split pages\n            if (horizontalPageBreakRepeat != null) {\n              repeatColumn = table.columns.find(function (item) {\n                return item.dataKey === horizontalPageBreakRepeat || item.index === horizontalPageBreakRepeat;\n              });\n              if (repeatColumn) {\n                cols.push(repeatColumn.index);\n                columns.push(table.columns[repeatColumn.index]);\n                remainingWidth = remainingWidth - repeatColumn.wrappedWidth;\n              }\n            }\n            while (i < len) {\n              if ((repeatColumn === null || repeatColumn === void 0 ? void 0 : repeatColumn.index) === i) {\n                i++; // prevent columnDataKeyToRepeat to be pushed twice in a page\n                continue;\n              }\n              var colWidth = table.columns[i].wrappedWidth;\n              if (remainingWidth < colWidth) {\n                // check if it's first column in the sequence then add it into result\n                if (i === 0 || i === config.start) {\n                  // this cell width is more than page width set it available pagewidth\n                  /* table.columns[i].wrappedWidth = availablePageWidth\n                  table.columns[i].minWidth = availablePageWidth */\n                  cols.push(i);\n                  columns.push(table.columns[i]);\n                }\n                // can't print more columns in same page\n                break;\n              }\n              cols.push(i);\n              columns.push(table.columns[i]);\n              remainingWidth = remainingWidth - colWidth;\n              i++;\n            }\n            return {\n              colIndexes: cols,\n              columns: columns,\n              lastIndex: i\n            };\n          };\n          var calculateAllColumnsCanFitInPage = function (doc, table) {\n            // const margins = table.settings.margin;\n            // const availablePageWidth = doc.pageSize().width - (margins.left + margins.right);\n            var allResults = [];\n            var index = 0;\n            var len = table.columns.length;\n            while (index < len) {\n              var result = getColumnsCanFitInPage(doc, table, {\n                start: index === 0 ? 0 : index\n              });\n              if (result && result.columns && result.columns.length) {\n                index = result.lastIndex;\n                allResults.push(result);\n              } else {\n                index++;\n              }\n            }\n            return allResults;\n          };\n          exports[\"default\"] = {\n            getColumnsCanFitInPage: getColumnsCanFitInPage,\n            calculateAllColumnsCanFitInPage: calculateAllColumnsCanFitInPage,\n            getPageAvailableWidth: getPageAvailableWidth\n          };\n\n          /***/\n        },\n\n        /***/189: /***/function (__unused_webpack_module, exports, __webpack_require__) {\n          Object.defineProperty(exports, \"__esModule\", {\n            value: true\n          });\n          exports.ellipsize = exports.resizeColumns = exports.calculateWidths = void 0;\n          var common_1 = __webpack_require__(200);\n          var tablePrinter_1 = __webpack_require__(435);\n          /**\n           * Calculate the column widths\n           */\n          function calculateWidths(doc, table) {\n            calculate(doc, table);\n            var resizableColumns = [];\n            var initialTableWidth = 0;\n            table.columns.forEach(function (column) {\n              var customWidth = column.getMaxCustomCellWidth(table);\n              if (customWidth) {\n                // final column width\n                column.width = customWidth;\n              } else {\n                // initial column width (will be resized)\n                column.width = column.wrappedWidth;\n                resizableColumns.push(column);\n              }\n              initialTableWidth += column.width;\n            });\n            // width difference that needs to be distributed\n            var resizeWidth = table.getWidth(doc.pageSize().width) - initialTableWidth;\n            // first resize attempt: with respect to minReadableWidth and minWidth\n            if (resizeWidth) {\n              resizeWidth = resizeColumns(resizableColumns, resizeWidth, function (column) {\n                return Math.max(column.minReadableWidth, column.minWidth);\n              });\n            }\n            // second resize attempt: ignore minReadableWidth but respect minWidth\n            if (resizeWidth) {\n              resizeWidth = resizeColumns(resizableColumns, resizeWidth, function (column) {\n                return column.minWidth;\n              });\n            }\n            resizeWidth = Math.abs(resizeWidth);\n            if (!table.settings.horizontalPageBreak && resizeWidth > 0.1 / doc.scaleFactor()) {\n              // Table can't get smaller due to custom-width or minWidth restrictions\n              // We can't really do much here. Up to user to for example\n              // reduce font size, increase page size or remove custom cell widths\n              // to allow more columns to be reduced in size\n              resizeWidth = resizeWidth < 1 ? resizeWidth : Math.round(resizeWidth);\n              console.error(\"Of the table content, \".concat(resizeWidth, \" units width could not fit page\"));\n            }\n            applyColSpans(table);\n            fitContent(table, doc);\n            applyRowSpans(table);\n          }\n          exports.calculateWidths = calculateWidths;\n          function calculate(doc, table) {\n            var sf = doc.scaleFactor();\n            var horizontalPageBreak = table.settings.horizontalPageBreak;\n            var availablePageWidth = tablePrinter_1.default.getPageAvailableWidth(doc, table);\n            table.allRows().forEach(function (row) {\n              for (var _i = 0, _a = table.columns; _i < _a.length; _i++) {\n                var column = _a[_i];\n                var cell = row.cells[column.index];\n                if (!cell) continue;\n                var hooks = table.hooks.didParseCell;\n                table.callCellHooks(doc, hooks, cell, row, column, null);\n                var padding = cell.padding('horizontal');\n                cell.contentWidth = (0, common_1.getStringWidth)(cell.text, cell.styles, doc) + padding;\n                var longestWordWidth = (0, common_1.getStringWidth)(cell.text.join(' ').split(/\\s+/), cell.styles, doc);\n                cell.minReadableWidth = longestWordWidth + cell.padding('horizontal');\n                if (typeof cell.styles.cellWidth === 'number') {\n                  cell.minWidth = cell.styles.cellWidth;\n                  cell.wrappedWidth = cell.styles.cellWidth;\n                } else if (cell.styles.cellWidth === 'wrap' || horizontalPageBreak === true) {\n                  // cell width should not be more than available page width\n                  if (cell.contentWidth > availablePageWidth) {\n                    cell.minWidth = availablePageWidth;\n                    cell.wrappedWidth = availablePageWidth;\n                  } else {\n                    cell.minWidth = cell.contentWidth;\n                    cell.wrappedWidth = cell.contentWidth;\n                  }\n                } else {\n                  // auto\n                  var defaultMinWidth = 10 / sf;\n                  cell.minWidth = cell.styles.minCellWidth || defaultMinWidth;\n                  cell.wrappedWidth = cell.contentWidth;\n                  if (cell.minWidth > cell.wrappedWidth) {\n                    cell.wrappedWidth = cell.minWidth;\n                  }\n                }\n              }\n            });\n            table.allRows().forEach(function (row) {\n              for (var _i = 0, _a = table.columns; _i < _a.length; _i++) {\n                var column = _a[_i];\n                var cell = row.cells[column.index];\n                // For now we ignore the minWidth and wrappedWidth of colspan cells when calculating colspan widths.\n                // Could probably be improved upon however.\n                if (cell && cell.colSpan === 1) {\n                  column.wrappedWidth = Math.max(column.wrappedWidth, cell.wrappedWidth);\n                  column.minWidth = Math.max(column.minWidth, cell.minWidth);\n                  column.minReadableWidth = Math.max(column.minReadableWidth, cell.minReadableWidth);\n                } else {\n                  // Respect cellWidth set in columnStyles even if there is no cells for this column\n                  // or if the column only have colspan cells. Since the width of colspan cells\n                  // does not affect the width of columns, setting columnStyles cellWidth enables the\n                  // user to at least do it manually.\n                  // Note that this is not perfect for now since for example row and table styles are\n                  // not accounted for\n                  var columnStyles = table.styles.columnStyles[column.dataKey] || table.styles.columnStyles[column.index] || {};\n                  var cellWidth = columnStyles.cellWidth || columnStyles.minCellWidth;\n                  if (cellWidth && typeof cellWidth === 'number') {\n                    column.minWidth = cellWidth;\n                    column.wrappedWidth = cellWidth;\n                  }\n                }\n                if (cell) {\n                  // Make sure all columns get at least min width even though width calculations are not based on them\n                  if (cell.colSpan > 1 && !column.minWidth) {\n                    column.minWidth = cell.minWidth;\n                  }\n                  if (cell.colSpan > 1 && !column.wrappedWidth) {\n                    column.wrappedWidth = cell.minWidth;\n                  }\n                }\n              }\n            });\n          }\n          /**\n           * Distribute resizeWidth on passed resizable columns\n           */\n          function resizeColumns(columns, resizeWidth, getMinWidth) {\n            var initialResizeWidth = resizeWidth;\n            var sumWrappedWidth = columns.reduce(function (acc, column) {\n              return acc + column.wrappedWidth;\n            }, 0);\n            for (var i = 0; i < columns.length; i++) {\n              var column = columns[i];\n              var ratio = column.wrappedWidth / sumWrappedWidth;\n              var suggestedChange = initialResizeWidth * ratio;\n              var suggestedWidth = column.width + suggestedChange;\n              var minWidth = getMinWidth(column);\n              var newWidth = suggestedWidth < minWidth ? minWidth : suggestedWidth;\n              resizeWidth -= newWidth - column.width;\n              column.width = newWidth;\n            }\n            resizeWidth = Math.round(resizeWidth * 1e10) / 1e10;\n            // Run the resizer again if there's remaining width needs\n            // to be distributed and there're columns that can be resized\n            if (resizeWidth) {\n              var resizableColumns = columns.filter(function (column) {\n                return resizeWidth < 0 ? column.width > getMinWidth(column) // check if column can shrink\n                : true; // check if column can grow\n              });\n\n              if (resizableColumns.length) {\n                resizeWidth = resizeColumns(resizableColumns, resizeWidth, getMinWidth);\n              }\n            }\n            return resizeWidth;\n          }\n          exports.resizeColumns = resizeColumns;\n          function applyRowSpans(table) {\n            var rowSpanCells = {};\n            var colRowSpansLeft = 1;\n            var all = table.allRows();\n            for (var rowIndex = 0; rowIndex < all.length; rowIndex++) {\n              var row = all[rowIndex];\n              for (var _i = 0, _a = table.columns; _i < _a.length; _i++) {\n                var column = _a[_i];\n                var data = rowSpanCells[column.index];\n                if (colRowSpansLeft > 1) {\n                  colRowSpansLeft--;\n                  delete row.cells[column.index];\n                } else if (data) {\n                  data.cell.height += row.height;\n                  colRowSpansLeft = data.cell.colSpan;\n                  delete row.cells[column.index];\n                  data.left--;\n                  if (data.left <= 1) {\n                    delete rowSpanCells[column.index];\n                  }\n                } else {\n                  var cell = row.cells[column.index];\n                  if (!cell) {\n                    continue;\n                  }\n                  cell.height = row.height;\n                  if (cell.rowSpan > 1) {\n                    var remaining = all.length - rowIndex;\n                    var left = cell.rowSpan > remaining ? remaining : cell.rowSpan;\n                    rowSpanCells[column.index] = {\n                      cell: cell,\n                      left: left,\n                      row: row\n                    };\n                  }\n                }\n              }\n            }\n          }\n          function applyColSpans(table) {\n            var all = table.allRows();\n            for (var rowIndex = 0; rowIndex < all.length; rowIndex++) {\n              var row = all[rowIndex];\n              var colSpanCell = null;\n              var combinedColSpanWidth = 0;\n              var colSpansLeft = 0;\n              for (var columnIndex = 0; columnIndex < table.columns.length; columnIndex++) {\n                var column = table.columns[columnIndex];\n                // Width and colspan\n                colSpansLeft -= 1;\n                if (colSpansLeft > 1 && table.columns[columnIndex + 1]) {\n                  combinedColSpanWidth += column.width;\n                  delete row.cells[column.index];\n                } else if (colSpanCell) {\n                  var cell = colSpanCell;\n                  delete row.cells[column.index];\n                  colSpanCell = null;\n                  cell.width = column.width + combinedColSpanWidth;\n                } else {\n                  var cell = row.cells[column.index];\n                  if (!cell) continue;\n                  colSpansLeft = cell.colSpan;\n                  combinedColSpanWidth = 0;\n                  if (cell.colSpan > 1) {\n                    colSpanCell = cell;\n                    combinedColSpanWidth += column.width;\n                    continue;\n                  }\n                  cell.width = column.width + combinedColSpanWidth;\n                }\n              }\n            }\n          }\n          function fitContent(table, doc) {\n            var rowSpanHeight = {\n              count: 0,\n              height: 0\n            };\n            for (var _i = 0, _a = table.allRows(); _i < _a.length; _i++) {\n              var row = _a[_i];\n              for (var _b = 0, _c = table.columns; _b < _c.length; _b++) {\n                var column = _c[_b];\n                var cell = row.cells[column.index];\n                if (!cell) continue;\n                doc.applyStyles(cell.styles, true);\n                var textSpace = cell.width - cell.padding('horizontal');\n                if (cell.styles.overflow === 'linebreak') {\n                  // Add one pt to textSpace to fix rounding error\n                  cell.text = doc.splitTextToSize(cell.text, textSpace + 1 / doc.scaleFactor(), {\n                    fontSize: cell.styles.fontSize\n                  });\n                } else if (cell.styles.overflow === 'ellipsize') {\n                  cell.text = ellipsize(cell.text, textSpace, cell.styles, doc, '...');\n                } else if (cell.styles.overflow === 'hidden') {\n                  cell.text = ellipsize(cell.text, textSpace, cell.styles, doc, '');\n                } else if (typeof cell.styles.overflow === 'function') {\n                  var result = cell.styles.overflow(cell.text, textSpace);\n                  if (typeof result === 'string') {\n                    cell.text = [result];\n                  } else {\n                    cell.text = result;\n                  }\n                }\n                cell.contentHeight = cell.getContentHeight(doc.scaleFactor());\n                var realContentHeight = cell.contentHeight / cell.rowSpan;\n                if (cell.rowSpan > 1 && rowSpanHeight.count * rowSpanHeight.height < realContentHeight * cell.rowSpan) {\n                  rowSpanHeight = {\n                    height: realContentHeight,\n                    count: cell.rowSpan\n                  };\n                } else if (rowSpanHeight && rowSpanHeight.count > 0) {\n                  if (rowSpanHeight.height > realContentHeight) {\n                    realContentHeight = rowSpanHeight.height;\n                  }\n                }\n                if (realContentHeight > row.height) {\n                  row.height = realContentHeight;\n                }\n              }\n              rowSpanHeight.count--;\n            }\n          }\n          function ellipsize(text, width, styles, doc, overflow) {\n            return text.map(function (str) {\n              return ellipsizeStr(str, width, styles, doc, overflow);\n            });\n          }\n          exports.ellipsize = ellipsize;\n          function ellipsizeStr(text, width, styles, doc, overflow) {\n            var precision = 10000 * doc.scaleFactor();\n            width = Math.ceil(width * precision) / precision;\n            if (width >= (0, common_1.getStringWidth)(text, styles, doc)) {\n              return text;\n            }\n            while (width < (0, common_1.getStringWidth)(text + overflow, styles, doc)) {\n              if (text.length <= 1) {\n                break;\n              }\n              text = text.substring(0, text.length - 1);\n            }\n            return text.trim() + overflow;\n          }\n\n          /***/\n        },\n\n        /***/84: /***/function (module) {\n          if (typeof __WEBPACK_EXTERNAL_MODULE__84__ === 'undefined') {\n            var e = new Error(\"Cannot find module 'undefined'\");\n            e.code = 'MODULE_NOT_FOUND';\n            throw e;\n          }\n          module.exports = __WEBPACK_EXTERNAL_MODULE__84__;\n\n          /***/\n        }\n\n        /******/\n      };\n      /************************************************************************/\n      /******/ // The module cache\n      /******/\n      var __webpack_module_cache__ = {};\n      /******/\n      /******/ // The require function\n      /******/\n      function __webpack_require__(moduleId) {\n        /******/ // Check if module is in cache\n        /******/var cachedModule = __webpack_module_cache__[moduleId];\n        /******/\n        if (cachedModule !== undefined) {\n          /******/return cachedModule.exports;\n          /******/\n        }\n        /******/ // Create a new module (and put it into the cache)\n        /******/\n        var module = __webpack_module_cache__[moduleId] = {\n          /******/ // no module.id needed\n          /******/ // no module.loaded needed\n          /******/exports: {}\n          /******/\n        };\n        /******/\n        /******/ // Execute the module function\n        /******/\n        __webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        /******/\n        /******/ // Return the exports of the module\n        /******/\n        return module.exports;\n        /******/\n      }\n      /******/\n      /************************************************************************/\n      var __webpack_exports__ = {};\n      // This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.\n      !function () {\n        var exports = __webpack_exports__;\n        Object.defineProperty(exports, \"__esModule\", {\n          value: true\n        });\n        exports.Cell = exports.Column = exports.Row = exports.Table = exports.CellHookData = exports.__drawTable = exports.__createTable = exports.applyPlugin = void 0;\n        var applyPlugin_1 = __webpack_require__(790);\n        var inputParser_1 = __webpack_require__(587);\n        var tableDrawer_1 = __webpack_require__(49);\n        var tableCalculator_1 = __webpack_require__(858);\n        var models_1 = __webpack_require__(287);\n        Object.defineProperty(exports, \"Table\", {\n          enumerable: true,\n          get: function () {\n            return models_1.Table;\n          }\n        });\n        var HookData_1 = __webpack_require__(662);\n        Object.defineProperty(exports, \"CellHookData\", {\n          enumerable: true,\n          get: function () {\n            return HookData_1.CellHookData;\n          }\n        });\n        var models_2 = __webpack_require__(287);\n        Object.defineProperty(exports, \"Cell\", {\n          enumerable: true,\n          get: function () {\n            return models_2.Cell;\n          }\n        });\n        Object.defineProperty(exports, \"Column\", {\n          enumerable: true,\n          get: function () {\n            return models_2.Column;\n          }\n        });\n        Object.defineProperty(exports, \"Row\", {\n          enumerable: true,\n          get: function () {\n            return models_2.Row;\n          }\n        });\n        // export { applyPlugin } didn't export applyPlugin\n        // to index.d.ts for some reason\n        function applyPlugin(jsPDF) {\n          (0, applyPlugin_1.default)(jsPDF);\n        }\n        exports.applyPlugin = applyPlugin;\n        function autoTable(d, options) {\n          var input = (0, inputParser_1.parseInput)(d, options);\n          var table = (0, tableCalculator_1.createTable)(d, input);\n          (0, tableDrawer_1.drawTable)(d, table);\n        }\n        // Experimental export\n        function __createTable(d, options) {\n          var input = (0, inputParser_1.parseInput)(d, options);\n          return (0, tableCalculator_1.createTable)(d, input);\n        }\n        exports.__createTable = __createTable;\n        function __drawTable(d, table) {\n          (0, tableDrawer_1.drawTable)(d, table);\n        }\n        exports.__drawTable = __drawTable;\n        try {\n          // eslint-disable-next-line @typescript-eslint/no-var-requires\n          var jsPDF = __webpack_require__(84);\n          // Webpack imported jspdf instead of jsPDF for some reason\n          // while it seemed to work everywhere else.\n          if (jsPDF.jsPDF) jsPDF = jsPDF.jsPDF;\n          applyPlugin(jsPDF);\n        } catch (error) {\n          // Importing jspdf in nodejs environments does not work as of jspdf\n          // 1.5.3 so we need to silence potential errors to support using for example\n          // the nodejs jspdf dist files with the exported applyPlugin\n        }\n        exports[\"default\"] = autoTable;\n      }();\n      /******/\n      return __webpack_exports__;\n      /******/\n    }()\n  );\n});","map":null,"metadata":{},"sourceType":"script"}